#!/bin/bash
# a bash script
# run with ./my.sh

ls
a=Hello
b="Hello World!"
c=12

echo $HOME
echo $MACHTYPE
echo
echo $b
echo $0
echo $SECONDS

# integer arithmetic can be done with double braces
d=$(($c+3*8))
echo "The value is "$d
((d--))
echo "Now it is "$d
((d+=2))
echo "And finally "$d

# without the (()) we have string manipulation
d+=2
echo $d
# pipe into bc for real number manipulation
f=$((1/3))
g=$(echo 1/3 | bc -l)
echo $f "," $g

# comparison can be done with [[ space expression space ]], gives true or flse
[[ "cat" == "cat" ]]
echo "cat equals cat?" $?
# one or two equals can be used, 0 is true, 1 is false
[[ "cat" = "dog" ]]
echo "cat equals dog? " $?
# but string comparison is default...
[[ 20 > 100 ]]
echo "20 > 100? " $?
[[ 20 -gt 100 ]]
echo "20 greater than 100? " $?
# and &&, or || and not ! are also available
[[ 0 || 1 ]]
echo "zero or 1?" $?
# test for null with -z and not null with -n
h=""
[[ -z $h ]]
echo "Is h null?" $?
# also concat like this
i=$a$b
echo $i
# show length, substring (from 0) etc
echo "Length of vble i: " ${#i}
j=${i:3:4}
echo "Third posn for 4 chars of i is: " $j 
echo "Backwards from end: " ${i: -5:3}
# search and replace one or two instances
k=${i/lo/be}
l=${i//lo/mp}
echo $k $l

#enable escape sequences with echo -e for coloured text
echo -e '\033[4;35;41mWoohoo\033[0m'
nicecol="\033[35;42;5m"
plain="\033[0m"
echo -e $nicecol "Like this" $plain

# alternatively
nicecol=$(tput setab 2; tput setaf 4; tput blink)
plain=$(tput sgr0)
echo -e $nicecol"Like this"$plain
# apparently blink is often disabled 'because it is really annoying'
# man date for formats available
today=$(date +"%d-%m-%Y")
# nice printing
printf "Name:\t%s\nID:\t%04d\n" "Me" "51"
printf -v vble "Current user:\t%s\nDate:\t\t%s\n" $USER $today
echo "$vble"

#arrays are  defined with braces, eg
m=()
n=("apple" "banana" "cherry")
echo ${n[0]}
# can add with non-contiguous indices
n[5]="kiwi"
# or at the end - () prevent 0th element being appended to
n+=("mango")
echo ${n[5]} ${n[6]}
# @ represents the whole array
echo ${n[@]}

# working with text files uses > to clear and write, or >> to append
echo "Some text" > file.txt
cat file.txt
echo "More text" >> file.txt
cat file.txt
#> file.txt

# reading text files with a while loop & incrementing vble
inc=1
while read f1; do
        echo "Line $inc: $f1"
        ((inc++))
done < file.txt
# can also read in a sequence of commands from a text file, and execute them

# here document, useful for user instructions, ensure delimiter is unique
# using cat as example command to feed it to.  Can also contain commands instead
# of reading them in from a file

cat << EndOfText
This is
a multiline
text string
EndOfText

#better formatting
cat <<- End0
	First
	Next
	Third
End0

# nice little system report
freespace=$(df -h / | grep -E "\/$" | awk '{print $4}')
greentext="\033[32m"
bold="\033[1m"
normal="\033[0m"
logdate=$(date +"%Y%m%d")
logfile="$logdate"_report.log

# \t is a tab
echo -e $bold"Quick system report for "$greentext"$HOSTNAME"$normal
printf "\tSystem type:\t%s\n" $MACHTYPE
printf "\tBash version:\t%s\n" $BASH_VERSION
printf "\tFree space:\t%s\n" $freespace
# wc -l counts lines, not words
printf "\tFiles in dir:\t%s\n" $(ls | wc -l)
printf "\tGenerated on:\t%s\n" $(date +"%d%m%y") # UK format
echo -e $greentext"A summary of this info saved to $logfile"$normal

cat <<- EOF > $logfile
	This report was automatically generated by my Bash script.
	It contains a brief summary of some system info.
EOF
printf "SYS:\t%s\n" $MACHTYPE >> $logfile
printf "BASH:\t%s\n" $BASH_VERSION >> $logfile
echo "Woohoo!" >> $logfile

# nano note: ctrl k to cut a line, ctrl u to paste it back (repeatedly if req)
# if statements
p=5
if [ $p -gt 4 ]; then  #other brackets/braces are available
	echo $p is greater than 4!
else
	echo $p is not greater than 4!
fi

# or with an else if (elif)

# or with a regular expression using =~
q="My str1ng!"
if [[ $q =~ [0-9]+ ]]; then
	echo "There are numbers in the string: $q"
else
	echo "There are no numbers in the string: $q"
fi

# while loop that counts to 10
count=0
while [ $count -le 10 ]; do
        echo count:$count
        ((count+=1))
done

# until loop
#c2=0 this vble name caused problems
# no it didn't, not leaving a space after [ caused infinite loop!
cnt=0
until [ $cnt -ge 10 ]; do
       echo cnt:$cnt
       ((cnt+=1))
done

# for loops
#for i in 1 2 3   # works, but a bit simple
for i in {1..20..2}  # instead use a regexp range, here with optional interval 2
do
       echo $i from for loop
done
# another style
for (( i=1; i<=10; i++ ))
do
       echo $i from second for loop
done
# can use a for loop over ordinary arrays; this eg is an associative one
declare -A arr
arr["name"]="Me"
arr["id"]="1234"
# use ! to access keys, and "" to protect against spaces in strings
for i in "${!arr[@]}"
do
       echo "$i: ${arr[$i]}"   # i contains the key
done
# command substitution
for i in $(ls)
do
       echo "$i"
done
# case statements, right brace ) indicates end of test, ;; indicate end of action
r="dog"
case $r in
        cat) echo "Feline";;
        dog|puppy) echo "Canine";;
        *) echo "No match!";;
esac

# use functions to make code modular; declare...
function greet {
        echo "Hi there!"
}
# ... and call
echo "And now, a greeting:"
greet
# function with arguments, defined by position
function greet2 {
        echo "Hi $1"
}

echo "And now, a personal greeting:"
greet2 Elizabeth

# big example with array of args

function numberthings {
        i=1
        for f in $@; do
                echo $i: $f
                ((i+=1))
        done
}

numberthings $(ls)
numberthings pine birch maple oak ash




# hoping to make this script long enough that run time measures at least 1s!
if [ $SECONDS -gt 0 ]; then
     echo $SECONDS Hooray!
else
     echo $SECONDS Boo!
fi
